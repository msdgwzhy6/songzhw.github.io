# How Kotlin use NDK in Android?


## A few steps to use NDK in Kotlin

First of all, I have to mention the version of Kotlin, NDK, AndoridStudio.  Because it seems not as same as the old versions.

- NDK : android-ndk-r10e
- Kotlin : 1.0.0-beta-1103
- Android Studio : 1.4.1

#### Step 1: modify [local.properties] in the project root directory

add a new line  (windows path is a littler different, please be careful)

```
ndk.dir=E\:\\android-ndk-r10e
```


#### Step 2: modify [gradle.properties] in the project root directory

add a new line

```
android.useDeprecatedNdk=true
```

#### Step 3:  modify [build.gradle] in the app module or the modules which are using NDK

add the ndk config in the android.defaultConfig path.

```groovy
android {
    defaultConfig {
        // ....

        ndk{
            moduleName "firstNdk"
        }

    }
}
```

#### Step 4: create a java class that is using JNI

I create a Java class that is in the package of cn.six.payx.util, and it is the JNI interface to me.


![](/imgs/20151114_01.png "build JniUtil.java here")


```java
package cn.six.payx.util;

public class JniUtil {

    public static native String getKey();
    public native int getNo();

    static{
        System.loadLibrary("firstNdk");
    }


}

```


**Note**: Yes, I use Java to conmunicate with C, **instead of Kotlin**.<br/>
Because Kotlin does not support the static memeber/function in Java, and native anntaion is changed in Kotlin 1.0.0 beta.
Now I have no clue about how to write JNI in Kotlin.  So I use Java.<br/>
Fortunately, Kotlin can use Java classes pretty easily.


#### Step 5: generate the .h file

![](/imgs/20151114_02.jpg)

please open your "cmd"(windows) or terminate(OS X), enters the source directory. 
By directory, I mean the "%project%/app/src/main/kotlin"

Then generate the .h file by input "javah -jni cn.six.payx.util.JniUtil"

```bash
$ cd ~/workspace/kotlinNdk/app/src/main/kotlin
$ javah -jni cn.six.payx.util.JniUtil
```
<p>

Then we have then "cn_six_payx_util_JniUtil.h" file
``` c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class cn_six_payx_util_JniUtil */

#ifndef _Included_cn_six_payx_util_JniUtil
#define _Included_cn_six_payx_util_JniUtil
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     cn_six_payx_util_JniUtil
 * Method:    getKey
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_cn_six_payx_util_JniUtil_getKey
  (JNIEnv *, jclass);

/*
 * Class:     cn_six_payx_util_JniUtil
 * Method:    getNo
 * Signature: ()I
 */
JNIEXPORT jint JNICALL Java_cn_six_payx_util_JniUtil_getNo
  (JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif
```


#### Step 6: code the *.c file

we try return a string in the getKey(), and return a int in the getNo().
```c
#include <cn_six_payx_util_JniUtil.h>

JNIEXPORT jstring JNICALL Java_cn_six_payx_util_JniUtil_getKey(JNIEnv *env, jclass clz) {
    #if defined(__arm__)
        #if defined(__ARM_ARCH_7A__)
          #if defined(__ARM_NEON__)
            #if defined(__ARM_PCS_VFP)
              #define ABI "armeabi-v7a/NEON (hard-float)"
            #else
              #define ABI "armeabi-v7a/NEON"
            #endif
          #else
            #if defined(__ARM_PCS_VFP)
              #define ABI "armeabi-v7a (hard-float)"
            #else
              #define ABI "armeabi-v7a"
            #endif
          #endif
        #else
         #define ABI "armeabi"
        #endif
    #elif defined(__i386__)
        #define ABI "x86"
    #elif defined(__x86_64__)
        #define ABI "x86_64"
    #elif defined(__mips64)  /* mips64el-* toolchain defines __mips__ too */
        #define ABI "mips64"
    #elif defined(__mips__)
        #define ABI "mips"
    #elif defined(__aarch64__)
    #define ABI "arm64-v8a"
    #else
        #define ABI "unknown"
    #endif

    return (*env)->NewStringUTF(env, "Hello from JNI !  Compiled with ABI " ABI ".");
}

JNIEXPORT jint JNICALL Java_cn_six_payx_util_JniUtil_getNo(JNIEnv *env, jobject obj) {
    return 2323;
}
```


Note : getKey() is a static method, and getNo() is not.



#### Step 7: run the project

Okay, Now everything is Okay. Please run the project, and you will get your required result.
 


###  Why I use Java class as a JNI interface?
Because Kotlin does not support static memeber and function. And kotlin's support is not stable: first native, now external. 

So I still choose java to as a jni interface, Kotlin can just call the java jni interface to get value.


### Source of this sample
The sample is in my "CleanBeta-Kotlin" prject, that is here :<br/>
<a href="https://github.com/songzhw/CleanBeta-Kotlin">https://github.com/songzhw/CleanBeta-Kotlin</a>




